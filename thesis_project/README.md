# Current Measurement Library
The Current Measurement Library provides an API for configuration and query of the PAC1720 current sensors. Multiple sensors can be controlled by means of the library. It is designed to be portable an can be adapted to an individual application by the adapter module. 

## Introduction
The driver module of the library contains its core functionality such as calculation of the sensor values. The adapter serves as wrapper for the driver and can be changed to the user's need in order to fit the library to an application. A generic communication interface is provided by the adapter module that allows the driver to communicate with the sensors by a serial bus such as the TWI. Therefore an implementation of the bus communication interface is to be provided by the programmer to the adapter. After initialization of the adapter module the measurements can be triggered and the results read from the driver's interface.

## Dependencies

Dependencies of the Current Measurement API used at its development:

+ avr-gcc version 6.3.0
+ bazel 0.24.0
+ EmbeddedSystemsBuildScripts 0.4.6

[Source Repo for some dependencies](http://bitbucket.es.uni-due.de:7990/projects/SPO/repos/st_ws1617_embedded/browse)


## Documentation

### Code Documentation

Code documentation is automatically generated by Doxygen. To generate the Documentation (`docs/` directory) the project has a Doxyfile with the required configuration.
The following call will generate the documentation:
```bash
doxygen Doxyfile
```

## Required configuration
Software was developed with avr-c compilers, target device was an Arduino Uno Rev.3 (tested too under Arduino Mega 2560) using the GPIO ports.

+ To be able to import this project with Eclipse, please refer to the Confluence documenation on how to import a project from Git into Eclipse.
+ USART is using a `BAUD_RATE` of 9600 to communicate the state of the application.
    - To read the logs use screen from eclipse or 

## How to flash

This project is based on `makefile`s, you'll need to set up a build configuration with Eclipse so it can generate the Makefiles and therefore being able to compile it successfully.

The following command will clean the build and compile it again, `build` is the desired Build Configuration directory generated by Eclipse.

```bash
cd build/
make clean && make
```

For programming it to the Arduino run the following command, this command requires the Arduino is connected to `path/to/device`, in this case the command for the Arduino Uno looks like:

+ Device type: m328p
+ Programmer: arduino
+ Baud Rate: 115200

```bash
cd build/
path/to/avrdude -pm328p -carduino -P/path/to/device -b115200 -Uflash:w:remote-sensors.hex:a
```

> Please mind that the remote-sensors.hex file depends on the local configuration/environment from Eclipse

For the Arduino Mega 2560

+ Device type: m2560
+ Programmer: stk500v2
+ Baud Rate: 115200
+ Mind the Erase Cycle is being deactivated with the flag `-D`.

## How to use the API

### Including it

Remote Sensor offers an API header file which includes the necessary file according to the configuration.

Since the Remote Sensor has an stateless communication protocol, registration of all URI's is optional. In order to include it define the symbol (macro/definition) `REMOTE_SENSOR_REGISTRATION` and the API header file will include the regisration protocol implementation with the project.

```c
#define REMOTE_SENSOR_REGISTRATION
/* This includes everything in the project */
#include <remote-sensor/api.h>
```

If the registration protocol is not needed, then include it as:

```c
/* This does not include the registration protocol */
#include <remote-sensor/api.h>
```

### ResourceManager

The ResourceManager is the API that takes care of all the resources registered, for creating a URI in the form of `/switch` first a Resource with the desired Handles have to be created and registered under the actual `URIComponent`.

```c
uint8_t parameter_limit = 0x06;
uint8_t buffer_size = 0x05;
ResourceManager.set_defaults(parameter_limit, buffer_size);

/* Create Resource */
Resource* dip_switch = ResourceManager.create("dip_switch", NOT_RESETTABLE, SINGLE_BUFFER, NOT_REALLOCATABLE, RESOURCE_MANAGER_DEFAULT);
PeripheralReadHandle read_handle = &SomeApi_function;
ResourceManager.attach_read_handle(read_handle, dip_switch);

/* Create a URI */
URIComponent* switch_uri = ResourceManager.create_identifier("switch");
ResourceManager.register_resource(dip_switch, switch_uri);

ResourceManager.register_component(switch_uri, ResourceManager.get_root_component());

```

#### So how do I access my resource?

The previous registered Resource can be accessed with the URI `/switch` or `/switch/`, for that matter to be more specific the action parameter can decide the resource to choose, therefore `/switch/?action=dip_switch` is the same, this explicitly says which Resource to use.
Of course, there can be more than one Resource attached to a URIComponent, let's say we have 2 `dip_switch`s and we register them under the same `URICompontent`, but with different name, `internal_dip_switch` vs `dip_switch`. However a resource can only be registered to one URIComponent. 

If a request comes with the following URI `/switch/` by default the first Resource to be registered under the URIComponent will be used, therefore `/switch/?action=dip_switch` calls the same handle, unless the following URI is requested `/switch/?action=internal_dip_switch`, would trigger the second resource.

### CommunicationController

Remote Sensors API project offers a very easy to use API. For a quick use simply call the following methods from the `controller.h` file:

```c
#define REMOTE_SENSOR_REGISTRATION
#include <remote-sensor/api.h>

/* ... */

uint8_t address[] = { /* the address */  };
size_t address_size = 8;  // bytes = 64 bits

uint8_t parameter_limit = 0x06;
uint8_t buffer_size = 0x05;

CommunicationController.init(parameter_limit, buffer_size);

/* Registration of Resources... */

/* This will register all the registered Resources */
RegistrationController.register_to(address, address_size);
/* This will listen for request from the gateway with the passed address */
while(1)
{
    CommunicationController.listen(address, address_size);
}
```

### Extending the CommunicationController

When extending the CommunicationController, be aware of the CtrlRecovery API. This API wraps the watchdog API, this is implemeted directly in the CommunicationController but it is canceled at registration and resumed once it is has finished the registration.

```c
/* init */
CtrlRecovery.init(T2S);

/* ok, this is meant to be called at the time you want to tell the MCU all is good */
CtrlRecovery.ok();

/* cancel */
CtrlRecovery.cancel();
```

## XCTU

The Remote Sensors project comes with 3 registered resources with the following URI's:

+ `/switch/`
+ `/switch/?freq=3` (For Stream connections)
+ `/temperature/`
+ `/light/`

When using Stream connections the URI can specify the frequency of the packages in a 1 second granularity, this of course, is optional. If not specified 1 second is used by default.

All of this resources support the `readings` parameter which implies the amount of sequential readings the handle will generate (this depends on Handle implementation), for example, `/switch/?readings=3` will return 3 readings from the switch.

Therefore under the directory `xctu` some files are included with a preconfigured header and body to request them, the `development_frame.xml` file includes the ACK responses for transactions 0 to 2 and the requests for each resource mentioned previously.

## Running Unit tests

Becuase of the dependency of the CommunicationMiddleware, we need to include a Dummy CommunicationMiddleware API struct when running the tests (only local), for doing this a definition will sufice.

```c
/* controller.h or any other file that includes controller.h */
#define LOCAL_TESTS
```

## How to use with py-logger

The Remote Sensor API project takes advantage of the `py-logger` functionality and uses the USART to log them.
For more information about refer to [py-logger](http://bitbucket.es.uni-due.de:7990/users/sjarsoli/repos/py-logger/browse).

Use the Logger's `LOG_LEVEL` definition to adjust the amount of logs to send through the USART.

```c
#include "src/communications/logger.h"

Logger.init(BAUD_RATE, LOGGER_DEBUG);

Logger.debug("...text...");
Logger.info("...text...");
Logger.warn("...text...");
Logger.critical("...text...");
Logger.error("...text...");

```

> As for the current version, the implementation of the `logger.h` in this project is incompatible with the Zigbee implementation of the CommunicationMiddleware.

## Change Log (Versions)

+ v0.4.1
    - Includes the basic `ONE_TIME` protocol
    - Includes the syncronous registration protocol
+ v0.5
    - Includes the `STREAM` protocol
+ v0.6
    - Inludes the deletion of `Resource`s and `URIComponent`s.
+ v1.0
    - Timeout in registration protocol (restarts the registration protocol).
    - Final Version.

# Contact

- Sensor API SS17 Team

